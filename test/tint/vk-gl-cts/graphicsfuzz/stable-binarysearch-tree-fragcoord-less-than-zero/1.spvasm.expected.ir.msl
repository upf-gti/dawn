SKIP: FAILED

../../src/tint/lang/msl/writer/printer/printer.cc:1257 internal compiler error: BST = struct @align(4) {
  data:i32 @offset(0)
  leftIndex:i32 @offset(4)
  rightIndex:i32 @offset(8)
}

main_out = struct @align(16) {
  x_GLF_color_1:vec4<f32> @offset(0), @location(0)
}

$B1: {  # root
  %tree_1:ptr<private, array<BST, 10>, read_write> = var
  %gl_FragCoord:ptr<private, vec4<f32>, read_write> = var
  %x_GLF_color:ptr<private, vec4<f32>, read_write> = var
}

%makeTreeNode_struct_BST_i1_i1_i11_i1_ = func(%tree:ptr<function, BST, read_write>, %data:ptr<function, i32, read_write>):void {
  $B2: {
    %7:ptr<function, i32, read_write> = access %tree, 0u
    %8:i32 = load %data
    store %7, %8
    %9:ptr<function, i32, read_write> = access %tree, 1u
    store %9, -1i
    %10:ptr<function, i32, read_write> = access %tree, 2u
    store %10, -1i
    ret
  }
}
%insert_i1_i1_ = func(%treeIndex:ptr<function, i32, read_write>, %data_1:ptr<function, i32, read_write>):void {
  $B3: {
    %baseIndex:ptr<function, i32, read_write> = var
    %param:ptr<function, BST, read_write> = var
    %param_1:ptr<function, i32, read_write> = var
    %param_2:ptr<function, BST, read_write> = var
    %param_3:ptr<function, i32, read_write> = var
    store %baseIndex, 0i
    loop [b: $B4, c: $B5] {  # loop_1
      $B4: {  # body
        %19:i32 = load %baseIndex
        %20:i32 = load %treeIndex
        %21:bool = lte %19, %20
        if %21 [t: $B6, f: $B7] {  # if_1
          $B6: {  # true
            exit_if  # if_1
          }
          $B7: {  # false
            exit_loop  # loop_1
          }
        }
        %22:i32 = load %data_1
        %23:i32 = load %baseIndex
        %24:ptr<private, i32, read_write> = access %tree_1, %23, 0u
        %25:i32 = load %24
        %26:bool = lte %22, %25
        if %26 [t: $B8, f: $B9] {  # if_2
          $B8: {  # true
            %27:i32 = load %baseIndex
            %28:ptr<private, i32, read_write> = access %tree_1, %27, 1u
            %29:i32 = load %28
            %30:bool = eq %29, -1i
            if %30 [t: $B10, f: $B11] {  # if_3
              $B10: {  # true
                %31:i32 = load %baseIndex
                %x_197:i32 = let %31
                %33:ptr<private, i32, read_write> = access %tree_1, %x_197, 1u
                %34:i32 = load %treeIndex
                store %33, %34
                %35:i32 = load %treeIndex
                %x_200:i32 = let %35
                %37:ptr<private, BST, read_write> = access %tree_1, %x_200
                %38:BST = load %37
                store %param, %38
                %39:i32 = load %data_1
                store %param_1, %39
                %40:void = call %makeTreeNode_struct_BST_i1_i1_i11_i1_, %param, %param_1
                %41:ptr<private, BST, read_write> = access %tree_1, %x_200
                %42:BST = load %param
                store %41, %42
                ret
              }
              $B11: {  # false
                %43:i32 = load %baseIndex
                %44:ptr<private, i32, read_write> = access %tree_1, %43, 1u
                %45:i32 = load %44
                store %baseIndex, %45
                continue  # -> $B5
              }
            }
            exit_if  # if_2
          }
          $B9: {  # false
            %46:i32 = load %baseIndex
            %47:ptr<private, i32, read_write> = access %tree_1, %46, 2u
            %48:i32 = load %47
            %49:bool = eq %48, -1i
            if %49 [t: $B12, f: $B13] {  # if_4
              $B12: {  # true
                %50:i32 = load %baseIndex
                %x_217:i32 = let %50
                %52:ptr<private, i32, read_write> = access %tree_1, %x_217, 2u
                %53:i32 = load %treeIndex
                store %52, %53
                %54:i32 = load %treeIndex
                %x_220:i32 = let %54
                %56:ptr<private, BST, read_write> = access %tree_1, %x_220
                %57:BST = load %56
                store %param_2, %57
                %58:i32 = load %data_1
                store %param_3, %58
                %59:void = call %makeTreeNode_struct_BST_i1_i1_i11_i1_, %param_2, %param_3
                %60:ptr<private, BST, read_write> = access %tree_1, %x_220
                %61:BST = load %param_2
                store %60, %61
                ret
              }
              $B13: {  # false
                %62:i32 = load %baseIndex
                %63:ptr<private, i32, read_write> = access %tree_1, %62, 2u
                %64:i32 = load %63
                store %baseIndex, %64
                continue  # -> $B5
              }
            }
            exit_if  # if_2
          }
        }
        unreachable
      }
      $B5: {  # continuing
        next_iteration  # -> $B4
      }
    }
    ret
  }
}
%search_i1_ = func(%t:ptr<function, i32, read_write>):i32 {
  $B14: {
    %index:ptr<function, i32, read_write> = var
    %currentNode:ptr<function, BST, read_write> = var
    %x_231:ptr<function, i32, read_write> = var
    store %index, 0i
    loop [b: $B15, c: $B16] {  # loop_2
      $B15: {  # body
        %70:i32 = load %index
        %71:bool = neq %70, -1i
        if %71 [t: $B17, f: $B18] {  # if_5
          $B17: {  # true
            exit_if  # if_5
          }
          $B18: {  # false
            exit_loop  # loop_2
          }
        }
        %72:i32 = load %index
        %73:ptr<private, BST, read_write> = access %tree_1, %72
        %74:BST = load %73
        store %currentNode, %74
        %75:ptr<function, i32, read_write> = access %currentNode, 0u
        %76:i32 = load %75
        %77:i32 = load %t
        %78:bool = eq %76, %77
        if %78 [t: $B19] {  # if_6
          $B19: {  # true
            %79:i32 = load %t
            %x_248:i32 = let %79
            ret %x_248
          }
        }
        %81:i32 = load %t
        %82:ptr<function, i32, read_write> = access %currentNode, 0u
        %83:i32 = load %82
        %84:bool = gt %81, %83
        if %84 [t: $B20, f: $B21] {  # if_7
          $B20: {  # true
            %85:ptr<function, i32, read_write> = access %currentNode, 2u
            %86:i32 = load %85
            store %x_231, %86
            exit_if  # if_7
          }
          $B21: {  # false
            %87:ptr<function, i32, read_write> = access %currentNode, 1u
            %88:i32 = load %87
            store %x_231, %88
            exit_if  # if_7
          }
        }
        %89:i32 = load %x_231
        store %index, %89
        continue  # -> $B16
      }
      $B16: {  # continuing
        next_iteration  # -> $B15
      }
    }
    ret -1i
  }
}
%main_1 = func():void {
  $B22: {
    %treeIndex_1:ptr<function, i32, read_write> = var
    %param_4:ptr<function, BST, read_write> = var
    %param_5:ptr<function, i32, read_write> = var
    %param_6:ptr<function, i32, read_write> = var
    %param_7:ptr<function, i32, read_write> = var
    %param_8:ptr<function, i32, read_write> = var
    %param_9:ptr<function, i32, read_write> = var
    %param_10:ptr<function, i32, read_write> = var
    %param_11:ptr<function, i32, read_write> = var
    %param_12:ptr<function, i32, read_write> = var
    %param_13:ptr<function, i32, read_write> = var
    %param_14:ptr<function, i32, read_write> = var
    %param_15:ptr<function, i32, read_write> = var
    %param_16:ptr<function, i32, read_write> = var
    %param_17:ptr<function, i32, read_write> = var
    %param_18:ptr<function, i32, read_write> = var
    %param_19:ptr<function, i32, read_write> = var
    %param_20:ptr<function, i32, read_write> = var
    %param_21:ptr<function, i32, read_write> = var
    %param_22:ptr<function, i32, read_write> = var
    %param_23:ptr<function, i32, read_write> = var
    %count:ptr<function, i32, read_write> = var
    %i:ptr<function, i32, read_write> = var
    %result:ptr<function, i32, read_write> = var
    %param_24:ptr<function, i32, read_write> = var
    store %treeIndex_1, 0i
    %116:ptr<private, BST, read_write> = access %tree_1, 0i
    %117:BST = load %116
    store %param_4, %117
    store %param_5, 9i
    %118:void = call %makeTreeNode_struct_BST_i1_i1_i11_i1_, %param_4, %param_5
    %119:ptr<private, BST, read_write> = access %tree_1, 0i
    %120:BST = load %param_4
    store %119, %120
    %121:i32 = load %treeIndex_1
    %122:i32 = add %121, 1i
    store %treeIndex_1, %122
    %123:i32 = load %treeIndex_1
    store %param_6, %123
    store %param_7, 5i
    %124:void = call %insert_i1_i1_, %param_6, %param_7
    %125:i32 = load %treeIndex_1
    %126:i32 = add %125, 1i
    store %treeIndex_1, %126
    %127:i32 = load %treeIndex_1
    store %param_8, %127
    store %param_9, 12i
    %128:void = call %insert_i1_i1_, %param_8, %param_9
    %129:i32 = load %treeIndex_1
    %130:i32 = add %129, 1i
    store %treeIndex_1, %130
    %131:i32 = load %treeIndex_1
    store %param_10, %131
    store %param_11, 15i
    %132:void = call %insert_i1_i1_, %param_10, %param_11
    %133:i32 = load %treeIndex_1
    %134:i32 = add %133, 1i
    store %treeIndex_1, %134
    %135:i32 = load %treeIndex_1
    store %param_12, %135
    store %param_13, 7i
    %136:void = call %insert_i1_i1_, %param_12, %param_13
    %137:i32 = load %treeIndex_1
    %138:i32 = add %137, 1i
    store %treeIndex_1, %138
    %139:i32 = load %treeIndex_1
    store %param_14, %139
    store %param_15, 8i
    %140:void = call %insert_i1_i1_, %param_14, %param_15
    %141:i32 = load %treeIndex_1
    %142:i32 = add %141, 1i
    store %treeIndex_1, %142
    %143:i32 = load %treeIndex_1
    store %param_16, %143
    store %param_17, 2i
    %144:void = call %insert_i1_i1_, %param_16, %param_17
    %145:i32 = load %treeIndex_1
    %146:i32 = add %145, 1i
    store %treeIndex_1, %146
    %147:i32 = load %treeIndex_1
    store %param_18, %147
    store %param_19, 6i
    %148:void = call %insert_i1_i1_, %param_18, %param_19
    %149:i32 = load %treeIndex_1
    %150:i32 = add %149, 1i
    store %treeIndex_1, %150
    %151:i32 = load %treeIndex_1
    store %param_20, %151
    store %param_21, 17i
    %152:void = call %insert_i1_i1_, %param_20, %param_21
    %153:i32 = load %treeIndex_1
    %154:i32 = add %153, 1i
    store %treeIndex_1, %154
    %155:i32 = load %treeIndex_1
    store %param_22, %155
    store %param_23, 13i
    %156:void = call %insert_i1_i1_, %param_22, %param_23
    store %count, 0i
    store %i, 0i
    loop [b: $B23, c: $B24] {  # loop_3
      $B23: {  # body
        %157:i32 = load %i
        %158:bool = lt %157, 20i
        if %158 [t: $B25, f: $B26] {  # if_8
          $B25: {  # true
            exit_if  # if_8
          }
          $B26: {  # false
            exit_loop  # loop_3
          }
        }
        %x_155:ptr<function, bool, read_write> = var
        %x_156:ptr<function, bool, read_write> = var
        %161:i32 = load %i
        store %param_24, %161
        %162:i32 = call %search_i1_, %param_24
        %x_136:i32 = let %162
        store %result, %x_136
        %164:i32 = load %i
        %x_137:i32 = let %164
        switch %x_137 [c: (2i 5i 6i 7i 8i 9i 12i 13i 15i 17i, $B27), c: (default, $B28)] {  # switch_1
          $B27: {  # case
            %166:i32 = load %result
            %167:i32 = load %i
            %168:bool = eq %166, %167
            %x_149:bool = let %168
            store %x_156, %x_149
            %170:bool = eq %x_149, false
            if %170 [t: $B29] {  # if_9
              $B29: {  # true
                %171:f32 = load_vector_element %gl_FragCoord, 0u
                %172:bool = lt %171, 0.0f
                store %x_155, %172
                %173:bool = load %x_155
                store %x_156, %173
                exit_if  # if_9
              }
            }
            %174:bool = load %x_156
            if %174 [t: $B30] {  # if_10
              $B30: {  # true
                %175:i32 = load %count
                %176:i32 = add %175, 1i
                store %count, %176
                exit_if  # if_10
              }
            }
            exit_switch  # switch_1
          }
          $B28: {  # case
            %177:i32 = load %result
            %178:bool = eq %177, -1i
            if %178 [t: $B31] {  # if_11
              $B31: {  # true
                %179:i32 = load %count
                %180:i32 = add %179, 1i
                store %count, %180
                exit_if  # if_11
              }
            }
            exit_switch  # switch_1
          }
        }
        continue  # -> $B24
      }
      $B24: {  # continuing
        %181:i32 = load %i
        %182:i32 = add %181, 1i
        store %i, %182
        next_iteration  # -> $B23
      }
    }
    %183:i32 = load %count
    %184:bool = eq %183, 20i
    if %184 [t: $B32, f: $B33] {  # if_12
      $B32: {  # true
        store %x_GLF_color, vec4<f32>(1.0f, 0.0f, 0.0f, 1.0f)
        exit_if  # if_12
      }
      $B33: {  # false
        store %x_GLF_color, vec4<f32>(0.0f, 0.0f, 1.0f, 1.0f)
        exit_if  # if_12
      }
    }
    ret
  }
}
%tint_symbol = @fragment func(%gl_FragCoord_param:vec4<f32> [@position]):main_out {
  $B34: {
    store %gl_FragCoord, %gl_FragCoord_param
    %187:void = call %main_1
    %188:vec4<f32> = load %x_GLF_color
    %189:main_out = construct %188
    ret %189
  }
}

invalid entry point IO struct uses
********************************************************************
*  The tint shader compiler has encountered an unexpected error.   *
*                                                                  *
*  Please help us fix this issue by submitting a bug report at     *
*  crbug.com/tint with the source program that triggered the bug.  *
********************************************************************
