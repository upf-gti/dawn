SKIP: FAILED

../../src/tint/lang/msl/writer/printer/printer.cc:500 internal compiler error: strided_arr = struct @align(4) {
  el:i32 @offset(0)
}

buf1 = struct @align(4) {
  x_GLF_uniform_int_values:array<strided_arr, 4> @offset(0)
}

strided_arr_1 = struct @align(4) {
  el:f32 @offset(0)
}

buf0 = struct @align(4) {
  x_GLF_uniform_float_values:array<strided_arr_1, 3> @offset(0)
}

main_out = struct @align(16) {
  x_GLF_color_1:vec4<f32> @offset(0), @location(0)
}

$B1: {  # root
  %x_6:ptr<uniform, buf1, read> = var @binding_point(0, 1)
  %x_8:ptr<uniform, buf0, read> = var @binding_point(0, 0)
  %x_GLF_color:ptr<private, vec4<f32>, read_write> = var
}

%main_1 = func():void {
  $B2: {
    %sums:ptr<function, array<f32, 2>, read_write> = var
    %a:ptr<function, i32, read_write> = var
    %b:ptr<function, i32, read_write> = var
    %c:ptr<function, i32, read_write> = var
    %d:ptr<function, i32, read_write> = var
    %indexable:ptr<function, mat2x2<f32>, read_write> = var
    %indexable_1:ptr<function, mat2x2<f32>, read_write> = var
    %x_158:ptr<function, bool, read_write> = var
    %x_159_phi:ptr<function, bool, read_write> = var
    %14:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
    %15:i32 = load %14
    %x_16:i32 = let %15
    %17:ptr<uniform, f32, read> = access %x_8, 0u, 0i, 0u
    %18:f32 = load %17
    %x_85:f32 = let %18
    %20:ptr<function, f32, read_write> = access %sums, %x_16
    %21:f32 = negation %x_85
    store %20, %21
    %22:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
    %23:i32 = load %22
    %x_18:i32 = let %23
    %25:ptr<uniform, f32, read> = access %x_8, 0u, 0i, 0u
    %26:f32 = load %25
    %x_90:f32 = let %26
    %28:ptr<function, f32, read_write> = access %sums, %x_18
    %29:f32 = negation %x_90
    store %28, %29
    %30:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
    %31:i32 = load %30
    %x_19:i32 = let %31
    store %a, %x_19
    loop [b: $B3, c: $B4] {  # loop_1
      $B3: {  # body
        %33:i32 = load %a
        %x_20:i32 = let %33
        %35:ptr<uniform, i32, read> = access %x_6, 0u, 0i, 0u
        %36:i32 = load %35
        %x_21:i32 = let %36
        %38:bool = lt %x_20, %x_21
        if %38 [t: $B5, f: $B6] {  # if_1
          $B5: {  # true
            exit_if  # if_1
          }
          $B6: {  # false
            exit_loop  # loop_1
          }
        }
        %39:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
        %40:i32 = load %39
        %x_22:i32 = let %40
        store %b, %x_22
        loop [b: $B7, c: $B8] {  # loop_2
          $B7: {  # body
            %42:i32 = load %b
            %x_23:i32 = let %42
            %44:ptr<uniform, i32, read> = access %x_6, 0u, 3i, 0u
            %45:i32 = load %44
            %x_24:i32 = let %45
            %47:bool = lt %x_23, %x_24
            if %47 [t: $B9, f: $B10] {  # if_2
              $B9: {  # true
                exit_if  # if_2
              }
              $B10: {  # false
                exit_loop  # loop_2
              }
            }
            %48:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
            %49:i32 = load %48
            %x_25:i32 = let %49
            store %c, %x_25
            loop [b: $B11, c: $B12] {  # loop_3
              $B11: {  # body
                %51:i32 = load %c
                %x_26:i32 = let %51
                %53:i32 = load %a
                %x_27:i32 = let %53
                %55:bool = lte %x_26, %x_27
                if %55 [t: $B13, f: $B14] {  # if_3
                  $B13: {  # true
                    exit_if  # if_3
                  }
                  $B14: {  # false
                    exit_loop  # loop_3
                  }
                }
                %56:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
                %57:i32 = load %56
                %x_28:i32 = let %57
                store %d, %x_28
                loop [b: $B15, c: $B16] {  # loop_4
                  $B15: {  # body
                    %59:i32 = load %d
                    %x_29:i32 = let %59
                    %61:ptr<uniform, i32, read> = access %x_6, 0u, 3i, 0u
                    %62:i32 = load %61
                    %x_30:i32 = let %62
                    %64:bool = lt %x_29, %x_30
                    if %64 [t: $B17, f: $B18] {  # if_4
                      $B17: {  # true
                        exit_if  # if_4
                      }
                      $B18: {  # false
                        exit_loop  # loop_4
                      }
                    }
                    %65:i32 = load %a
                    %x_31:i32 = let %65
                    %67:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
                    %68:i32 = load %67
                    %x_32:i32 = let %68
                    %70:f32 = convert %x_32
                    %x_125:f32 = let %70
                    %72:i32 = load %c
                    %x_33:i32 = let %72
                    %74:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
                    %75:i32 = load %74
                    %x_34:i32 = let %75
                    %77:vec2<f32> = construct %x_125, 0.0f
                    %78:vec2<f32> = let %77
                    %79:vec2<f32> = construct 0.0f, %x_125
                    %80:mat2x2<f32> = construct %78, %79
                    store %indexable, %80
                    %81:ptr<function, vec2<f32>, read_write> = access %indexable, %x_33
                    %82:f32 = load_vector_element %81, %x_34
                    %x_131:f32 = let %82
                    %84:ptr<function, f32, read_write> = access %sums, %x_31
                    store %84, %x_131
                    %85:i32 = load %a
                    %x_35:i32 = let %85
                    %87:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
                    %88:i32 = load %87
                    %x_36:i32 = let %88
                    %90:f32 = convert %x_36
                    %x_134:f32 = let %90
                    %92:i32 = load %c
                    %x_37:i32 = let %92
                    %94:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
                    %95:i32 = load %94
                    %x_38:i32 = let %95
                    %97:vec2<f32> = construct %x_134, 0.0f
                    %98:vec2<f32> = let %97
                    %99:vec2<f32> = construct 0.0f, %x_134
                    %100:mat2x2<f32> = construct %98, %99
                    store %indexable_1, %100
                    %101:ptr<function, vec2<f32>, read_write> = access %indexable_1, %x_37
                    %102:f32 = load_vector_element %101, %x_38
                    %x_140:f32 = let %102
                    %104:ptr<function, f32, read_write> = access %sums, %x_35
                    %105:f32 = load %104
                    %x_142:f32 = let %105
                    %107:ptr<function, f32, read_write> = access %sums, %x_35
                    %108:f32 = add %x_142, %x_140
                    store %107, %108
                    continue  # -> $B16
                  }
                  $B16: {  # continuing
                    %109:i32 = load %d
                    %x_39:i32 = let %109
                    %111:i32 = add %x_39, 1i
                    store %d, %111
                    next_iteration  # -> $B15
                  }
                }
                continue  # -> $B12
              }
              $B12: {  # continuing
                %112:i32 = load %c
                %x_41:i32 = let %112
                %114:i32 = add %x_41, 1i
                store %c, %114
                next_iteration  # -> $B11
              }
            }
            continue  # -> $B8
          }
          $B8: {  # continuing
            %115:i32 = load %b
            %x_43:i32 = let %115
            %117:i32 = add %x_43, 1i
            store %b, %117
            next_iteration  # -> $B7
          }
        }
        continue  # -> $B4
      }
      $B4: {  # continuing
        %118:i32 = load %a
        %x_45:i32 = let %118
        %120:i32 = add %x_45, 1i
        store %a, %120
        next_iteration  # -> $B3
      }
    }
    %121:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
    %122:i32 = load %121
    %x_47:i32 = let %122
    %124:ptr<function, f32, read_write> = access %sums, %x_47
    %125:f32 = load %124
    %x_147:f32 = let %125
    %127:ptr<uniform, f32, read> = access %x_8, 0u, 1i, 0u
    %128:f32 = load %127
    %x_149:f32 = let %128
    %130:bool = eq %x_147, %x_149
    %x_150:bool = let %130
    store %x_159_phi, %x_150
    if %x_150 [t: $B19] {  # if_5
      $B19: {  # true
        %132:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
        %133:i32 = load %132
        %x_48:i32 = let %133
        %135:ptr<function, f32, read_write> = access %sums, %x_48
        %136:f32 = load %135
        %x_155:f32 = let %136
        %138:ptr<uniform, f32, read> = access %x_8, 0u, 2i, 0u
        %139:f32 = load %138
        %x_157:f32 = let %139
        %141:bool = eq %x_155, %x_157
        store %x_158, %141
        %142:bool = load %x_158
        store %x_159_phi, %142
        exit_if  # if_5
      }
    }
    %143:bool = load %x_159_phi
    %x_159:bool = let %143
    if %x_159 [t: $B20, f: $B21] {  # if_6
      $B20: {  # true
        %145:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
        %146:i32 = load %145
        %x_49:i32 = let %146
        %148:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
        %149:i32 = load %148
        %x_50:i32 = let %149
        %151:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
        %152:i32 = load %151
        %x_51:i32 = let %152
        %154:ptr<uniform, i32, read> = access %x_6, 0u, 2i, 0u
        %155:i32 = load %154
        %x_52:i32 = let %155
        %157:f32 = convert %x_49
        %158:f32 = let %157
        %159:f32 = convert %x_50
        %160:f32 = let %159
        %161:f32 = convert %x_51
        %162:f32 = let %161
        %163:f32 = convert %x_52
        %164:vec4<f32> = construct %158, %160, %162, %163
        store %x_GLF_color, %164
        exit_if  # if_6
      }
      $B21: {  # false
        %165:ptr<uniform, i32, read> = access %x_6, 0u, 1i, 0u
        %166:i32 = load %165
        %x_53:i32 = let %166
        %168:f32 = convert %x_53
        %x_173:f32 = let %168
        %170:vec4<f32> = construct %x_173, %x_173, %x_173, %x_173
        store %x_GLF_color, %170
        exit_if  # if_6
      }
    }
    ret
  }
}
%tint_symbol = @fragment func():main_out {
  $B22: {
    %172:void = call %main_1
    %173:vec4<f32> = load %x_GLF_color
    %174:main_out = construct %173
    ret %174
  }
}

unhandled variable address space
********************************************************************
*  The tint shader compiler has encountered an unexpected error.   *
*                                                                  *
*  Please help us fix this issue by submitting a bug report at     *
*  crbug.com/tint with the source program that triggered the bug.  *
********************************************************************
